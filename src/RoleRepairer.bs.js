// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function findRepairTargets(spawn) {
  return spawn.room.find(107).filter(function (structure) {
              if (structure.hits < (structure.hitsMax - 2000 | 0)) {
                return Caml_obj.caml_notequal(structure.structureType, STRUCTURE_WALL);
              } else {
                return false;
              }
            });
}

function roleRepairer(spawn, creep) {
  if (creep.memory.repairing && creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {
    creep.memory.repairing = false;
  }
  if (!creep.memory.repairing && creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {
    creep.memory.repairing = true;
  }
  if (creep.memory.repairing) {
    var closestDamagedStructure = creep.pos.findClosestByRange(findRepairTargets(spawn));
    var closestDamagedStructure$1 = (closestDamagedStructure == null) ? undefined : Caml_option.some(closestDamagedStructure);
    if (Belt_Option.isSome(closestDamagedStructure$1) && Caml_obj.caml_equal(creep.repair(closestDamagedStructure$1), ERR_NOT_IN_RANGE)) {
      creep.moveTo(closestDamagedStructure$1.pos);
      return ;
    } else {
      return ;
    }
  }
  var resources = creep.room.find(106);
  if (Caml_obj.caml_equal(creep.pickup(Caml_array.get(resources, 1)), ERR_NOT_IN_RANGE)) {
    creep.moveTo(Caml_array.get(resources, 1).pos);
    return ;
  }
  
}

exports.findRepairTargets = findRepairTargets;
exports.roleRepairer = roleRepairer;
/* No side effect */
